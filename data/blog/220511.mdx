---
title: 220511 Today I Learned
date: "2022-05-11"
tags:
  [
    "daily",
    "study",
    "javascript",
    "apollo",
    "graphql",
    "hbr",
    "nomadcoders",
    "speak",
  ]
draft: false
summary:
images: []
layout: PostLayout
---

<br />

# Today Plan

- [x] InstaClone # 11.0 ~ 11.6
- [x] DeepDive JS # 40
- [x] HBR reading 1.1 Review ~ 1.2 Reading twice
- [ ] HBR speaking 1.1
- [ ] Figma
- [x] Running 10km / Weight training

<br />

# Today Summary

- Speak 문장 연습량을 200 문장에서 100문장으로 하향 조정 해서 목표 달성률을 높였다.
- HRB 영어 공부를 하며 아직 독해 능력이 아직 많이 부족함을 느꼈다. 단어 열심히 익히고, 꾸준히 쉐도잉 해야할 것 같고 <br />
  `<혼자 공부하는 시간의 힘>` 에서 익혔던 영어 공부법에 대해서 다시 한 번 Review 해보는 것이 필요할 것 같다.
- 참고 : https://blog-geonya.vercel.app/blog/220508 : 좌절 없이 지속하는 외국어 공부법
- `DeepDive Javascript` 책에서 Ch.40 `Event` 파트를 읽었다.
- `nomadcoders`의 인스타클론 강의를 50% 수강했다.
- Photo Feed 파트에서 `useUser` hook 을 만들어 token을 검증하는 것이 흥미로웠다.
- Photo Model에 isLiked Query를 새로 만들며 느낀 것인데 `GraphQL`과 `Aplloserver` 덕분에 백엔드와 프론트엔드에서 자유자재로 데이터를 다룰 수 있어 정말 효율적이다.
- `TypeScript`에서 기본기가 부족하다는 생각을 점점 더 많이 하게 된다. `DeepDive Javascript` 책을 다 읽고 TypeScript 책도 한 번 독파해봐야할 것 같다
- 3시가 되기 전에 회의에 불려가는 바람에 예상보다 공부를 많이 하지 못했다.
- 밤에 조깅을 10km 했다. 7~8km 까지는 크게 무리 없이 뛸 수 있는 것 같다. 이후에 push-up을 50회 했다.
- 운동을 마치고 보라와 1400일 기념으로 매일 조깅 출발하는 곳에서 향을 풍기며 식욕을 돋구던 `본스치킨`을 드디어 먹어보았다. 정말 맛있었다.

<br />

# DeepDive Javascript Ch.40 Event

## 이벤트 드리븐 프로그래밍

- 브라우저는 처리해야할 특정 사건이 발생하면 이벤트 event 를 발생 trigger 시킨다.
- 예를 들어 : 마우스 이동 / 클릭, 키보드 입력

- 이벤트가 발생했을 때 호출될 함수를 `이벤트 핸들러` `event handler`
- 핸들러의 호출을 위임하는 것을 `이벤트 핸들러 등록` 이라고 한다.

- 이벤트가 언제 발생하고 이벤트 핸들러는 언제 호출할 지 알 수 없으므로 명시적으로 함수를 호출하는 것이 아니라 브라우저에게 함수 호출을 위임한다.

- 이벤트와 그에 대응하는 함수(이벤트 핸들러)를 통해 사용자와 애플리케이션은 상호작용을 할 수 있다.
- 이벤트 중심으로 프로그래밍의 흐름을 제어하는 방식을 `이벤트 드리븐 프로그래밍` 이라고 함

## 40.2 이벤트 타입

### 마우스 이벤트

- click : 마우스를 클릭
- dblclick : 마우스를 더블클릭
- mousedown : 마우스 버튼을 눌렀을 때
- mouseup : 누르고 있던 마우스 버튼을 놓았을 때
- mousemove : 마우스 커서를 움직였을 때
- mouseenter : 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 되지 않는다)
- mouseover : 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링된다)
- mouseleave : 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링되지 않는다)
- mouseout : 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링된다)

#### 버블링이란 ?

- 이벤트가 제일 깊은 곳에 있는 요소에서 시작해 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품(bubble)과 닮았기 때문에 버블링이라고 부른다.

### 키보드 이벤트

- keydown : 모든 키를 눌렀을 때 발생
- keypress : 모든 키를 눌렀을 때 연속적으로 발생
- keyup : 누르고 있던 키를 놓았을 때 한 번만 발생

### 포커스 이벤트

- focus : HTML 요소가 포커스를 받았을 때 (버블링되지 않는다)
- blur : HTML 요소가 포커스를 잃었을 때 (버블링되지 않는다)
- focusin : HTML 요소가 포커스를 받았을 때 (버블링된다)
- focuesout : HTML 요소가 포커스를 잃었을 때 (버블링된다)

- (focusin과 focuesout 이벤트 핸들러는 addEventListener 메서드 방식을 사용해 등록해야 한다.)

### 폼 이벤트

- submit :
  1. form 요소 내의 input, select 입력 필드에서 엔터 키를 눌렀을 때
  2. from 요소 내의 submit 버튼 (<button>, <input type="submit">)을 클릭 했을 때
  - submit 이벤트는 form 요소에서 발생한다.

### 값 변경 이벤트

- input : input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때
- change : input(text, checkbox, radio), select, textareat 요소의 값이 변경되었을 때
- readystatechange : HTML 문서의 로드와 파싱 상태를 나타내는 documnet.readyState 프로퍼티 값("loading", "interfactive", "complete")이 변경될 때

### DOM Mutation 이벤트

- DOMContentLoaded : HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때

### 뷰 이네트

- resize : 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생한다.
- scroll : 웹페이지 또는 HTML 요소를 스크롤할 때 연속적으로 발생한다.

### 리소스 이벤트

- load : DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료되었을 때 (주로 window 객체에서 발생)
- unload : 리소스가 언로드될 때(주로 새로운 웹페이지를 요청한 경우)
- abort : 리소스 로딩이 중단되었을 때
- error : 리소스 로딩이 실패했을 때

## 40.3 이벤트 핸들러 등록

- **이벤트 핸들러** : 이벤트가 발생하면 브라우저에 의해 호출될 함수

### 이벤트 핸들러 어트리뷰트 방식

```html
<button onclick="sayHi("han")">Click me! </button>
<script>
  function sayHi(name) {
    console.log(`Hi!, ${name}`);
  }
</script>
```

- HTML 요소의 어트리뷰트 중에는 이벤트에 대응하는 이벤트 핸들러 어트리뷰트가 있다.

- 이벤트 핸들러를 등록할 때 콜백 함수와 마찬가지로 함수 참조를 등록해야 브라우저가 이벤트 핸들러를 호출할 수 있다.

### 이벤트 핸들러 프로퍼티 방식

- 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.

```js
$button.onclick = function () => {
  console.log("button clicked");
}
```

- 이벤트를 발생시킬 객체인 이벤트 타깃과 이벤트의 종류를 나타내는 문자열 이벤트 타입 그리고 이벤트 핸들러를 지정하여 이벤트 핸들러 등록

### addEventListener 메서드 방식

```js
EventTarget.addEventListener("eventType", callBackFunc, [useCapture]);
// capture 사용 여부
// - true : capturing
// - false : bubbling (기본값)
```

- addEventListener 메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.

## 40.4 이벤트 핸들러 제거

```js
EventTarget.removeEventListener("eventType", callBackFunc);
```

- callBackFunc 가 무명 함수로 전달한 경우 이벤트 리스너를 제거할 수 없다.

## 40.5 이벤트 객체

- 이벤트가 발생하면 이벤트에 관련된 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다.
- 이 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.

- type : 이벤트 타입
- target : 이벤트를 발생시킨 DOM 요소
- currentTarget : 이벤트 핸들러가 바인딩된 DOM 요소
- eventPhase : 이벤트 전파 단계
- bubbles: 이벤트를 버블링으로 전파하는 여부
- cancelable : preventDefault 메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부
- defaultPrevented : preventDefault 메서드를 호출하여 이벤트를 취소했는지 여부
- isTrusted : 사용자의 행위에 의해 발생한 이벤트인지 여부
- timeStamp : 이벤트가 발생한 시각

### 마우스 정보 취득

- 마우스 포인터의 좌표 정보를 나타내는 프로퍼티 : screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
- 버튼 정보를 나타내는 프로퍼티 : altKey, ctrlKey, shiftKey, button

### 키보드 정보 취득

- keydown, keyup, keypress 이벤트 발생하면 생성되는 이벤트 객체의 프로퍼티 : altKey, crtilKey, shiftKey, meataKey, key

### 이벤트 전파

- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파

- 캡처링 단계 (caputring phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계 (target phase) : 이벤트가 이벤트 타깃에 도달
- 버블링 단계 (bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파

- 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다. (cpaturing 과 bubbling 속성을 이용하여)

### 이벤트 위임

- 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법

```html
<ul id="fruits">
	<li id="apple" class="activate">Apple</li>
	<li id="banana">Apple</li>
	<li id="orange">Apple</li>
</ul>
```

```js
function activate({ target }) {
	if (!target.matches("#fruits > li")) return;
	[...$fruits.children].forEach(($fruit) => {
		$fruit.classList.toggle("active", $fruit === target);
		$msg.textContent = target.id;
	});
}

$fruits.onclick = activate;
```

## 40.8 DOM 요소의 기본 동작 조작

### DOM 요소의 기본 동작 중단

- 이벤트 객체의 preventDefault 메서드는 이러한 DOM 요소의 기본 동작을 중단시킨다.

### 이벤트 전파 방지

- 이벤트 객체의 stopPropagation 메서드는 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트의 전파를 중단시킨다.

## 40.9 이벤트 핸들러 내부의 this

- 이벤트 핸들러 어트리뷰트 방식

```js
<button onclick="handleClick()">Click me </button>
<script>
  function handleClick() {
    console.log(this); // window
  }
```

- 일반 함수로서 호출되는 함수 내부의 this는 전역 객체를 가리킨다.
- 단, 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.

```js
<button onclick="handleClick(this)">Click me </button>
<script>
  function handleClick(button) {
    console.log(button) // 이벤트를 바인딩한 button 요소
    console.log(this); // window
  }
```

### 이벤트 핸들러 프로퍼티 방식돠 addEventListener 메서드 방식

- 이벤트 핸들러 방식과 addEventListener 메서드 방식 모두 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.
- 즉, 이벤트 핸들러 내부의 this 는 이벤트 객체의 currentTarget 프로퍼티와 같다.

- 화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코르의 this를 가리킨다. 화살표 함수는 함수 자체의 this 바인딩을 갖지 않기 때문

## 40.10 이벤트 핸들러에 인수 전달

- 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식의 경우 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야 한다. 따라서 인수를 전달할 수 없다.
- 그러나 인수를 전달할 방법이 전혀 없는 것은 아니다.

```js
const checkUserNameLength = (min) => {
	$msg.textContent =
		$input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : "";
};

$input.onblur = () => {
	checkUserNameLength(MIN_USERNAME_LENGTH);
};
```

- 또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수도 있다

```js
const checkUserNameLength = (min) => (e) => {
	$msg.textContent =
		$input.value.length < min ? `이름은 ${min}자 이상 입력해주세요` : "";
};
$input.onblur = checkUserNameLength(MIN_USERNAME_LENGTH);
```

- checkUserNameLength 함수는 함수를 반환한다.
- 따라서 $input.onblur 에는 결국 checkUserNameLength 함수가 반환하는 함수가 바인딩된다.

## 40.11 커스텀 이벤트

- Event, UIEvent, MouseEvent 같은 이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트 객체는 임의이 이벤트 타입을 지정할 수 있다.
- 이처럼 개발자의 의도로 생성된 이벤트를 커스텀 이벤트라 한다.

<br />

# InstaClone # 11 FEED

- Layout component 를 만들어 사용하면 컴포넌트 배치를 관리하기 용이하다.

```tsx
interface ILayout {
	children: React.ReactNode;
}
const Layout = ({ children }: ILayout) => {
	return (
		<>
			<Header />
			<Content>{children}</Content>
		</>
	);
};
```

## Ch.11.1 Check Token with useUser Hook

- 누군가 브라우저의 token 을 임의로 변형하여 악용할 수도 있기 때문에
- 우리가 가지고 있는 token 이 실제 token 인지 확인하는 방법
- useUser hook 을 만들어 loggedInUser 여부를 UseReactiveVar 을 통해 확인한다 (token 이 있냐 없냐만 확인하는 절차임)
- Backend 에 seeMe Query 를 만들어 loggedInUser 의 id로 user 모델에서 findUnique 한다. (로그인한 유저의 데이터를 찾는 과정)
- 해당 Query를 Front 로 가져와 useQuery 를 실행한다. (나는 codegenerator를 이용하고 있기 때문에 useSeeMeQuery 를 자동 생성했다.)

```tsx
const { data, error } = useSeeMeQuery({ skip: !isLoggedIn });
// 만약 token 을 가지고 있지 않다면 Query를 실행하지 않는다.
```

- useQuery 를 이용해 data 를 가져온다.

## Ch.11.2 Header part 3 :

- useUser Hook 에 useEffect 훅을 이용하여 만약 useQuery 에서 가져온 data 가 null 이라면 logout 시킨다 (즉, token을 통해 검증이 실패한다면)
- 이제 백엔드로 request 할 때 header에 token을 넣어서 보내줘야지 백엔드에서 검증을 할 수 있다.
- apollo.ts 에서 authLink 를 이용한다.
- setContext 함수를 이용하여 prevContext 인자에 headers에서 token을 추가하여 return 한다.
- ApolloClient 인스턴스에 link 부분에 concat 메서드를 이용하여 authLink 와 새로 정의한 httpLink를 연결한다. (여기에서 concat 메서드는 ApolloLink 클래스의 메서드로 배열 concat 과는 다르다.)

## Ch.11.3 Avatar

- useUser에서 data를 return 하여 Header에서 data를 꺼내 avatar 가 존재할 경우 보여주기 위해 Avatar 컴포넌트를 만든다.
- Avatar 컴포넌트에서는 avatar url이 존재할 경우 / 아닐 경우를 구분하여 존재할 경우 Avatar Url 을 url 프로퍼티 값으로 갖는 Image 컴포넌트를 생성한다.

## Ch.11.4 Photo Component 1

- seeFeed 를 위한 useQuery 를 만든다.
- data를 잘 받아오는지 확인하고 data를 map 으로 돌려 데이터들을 추출해서 화면에 뿌린다.
- 데이터를 화면에 보여주기 위한 PhotoComponent 를 만든다. (Container / Header 등 …)

## Ch.11.5 Photo Component 2

- Photo components CSS setting

## Ch.11.6 isLiked ?

- Backend 에서 photo의 typeDefs 에서 isLiked 를 추가하고 resolver를 새로 만들어준다.

```tsx
interface IPhotoProps {
	photo: Partial<Photo>;
}
```

- Photobox 로 보내는 prop photo가 Photo model type의 부분 집합인데 이를 어떻게 정의할지에 대해 고민하고 있다.

<br />
